import { useConfig as f } from "./useConfig.js";
import { ssrState as p, combineUrlAndPath as v } from "@scalar/oas-utils/helpers";
import { slug as c } from "github-slugger";
import { ref as s } from "vue";
const u = s(""), l = s(p.hash ?? ""), r = s(), m = s(!1), h = (t) => {
  var n;
  if (!r.value)
    return "";
  const a = new RegExp("^" + ((n = r.value) == null ? void 0 : n.basePath) + "/?");
  return decodeURIComponent(t.replace(a, ""));
}, w = (t = l.value) => {
  var i;
  const a = (i = t.match(/(tag\/[^/]+)/)) == null ? void 0 : i[0], n = t.startsWith("model") ? "models" : "", o = t.startsWith("webhook") ? "webhooks" : "";
  return a || n || o;
}, I = () => {
  l.value = r.value ? h(window.location.pathname) : (
    // Must remove the prefix from the hash as the internal hash value should be pure
    decodeURIComponent(window.location.hash.replace(/^#/, "")).slice(u.value.length)
  );
}, $ = (t, a = window.location.href) => {
  const n = new URL(a);
  r.value ? n.pathname = v(r.value.basePath, t) : n.hash = u.value + t, l.value = t, window.history.replaceState({}, "", n);
}, S = (t, a = window.location.href, n = window.location.search) => {
  const o = new URL(a);
  return o.hash = u.value + t, o.search = n, o.toString();
}, U = (t = l.value) => `${u.value}${t}`, b = () => decodeURIComponent(window.location.hash.replace(/^#/, "").slice(u.value.length)), x = () => {
  const t = f(), a = (e) => typeof t.value.generateHeadingSlug == "function" ? `${t.value.generateHeadingSlug(e)}` : e.slug ? `description/${e.slug}` : "", n = (e) => e != null && e.name ? typeof t.value.generateModelSlug == "function" ? `model/${t.value.generateModelSlug(e)}` : `model/${c(e.name)}` : "models", o = (e) => typeof t.value.generateTagSlug == "function" ? `tag/${t.value.generateTagSlug(e)}` : `tag/${c(e.name)}`;
  return {
    hash: l,
    /** Sets the prefix for the hash */
    setHashPrefix: (e) => {
      u.value = e;
    },
    /**
     * Gets the full hash with the prefix
     * @param hashTarget The hash to target with the return
     * @returns The full hash
     */
    getFullHash: U,
    /**
     * Gets the hashed url with the prefix
     * @param replacementHash The hash to replace the current hash with
     * @param url The url to get the hashed url from
     * @returns The hashed url
     */
    getHashedUrl: S,
    /**
     * Replaces the URL state with the new url and hash
     * Replacement is used so that hash changes don't trigger the url hash watcher and cause a scroll
     */
    replaceUrlState: $,
    /** Gets the portion of the hash used by the references */
    getReferenceHash: b,
    getWebhookId: (e) => e != null && e.name ? typeof t.value.generateWebhookSlug == "function" ? `webhook/${t.value.generateWebhookSlug(e)}` : `webhook/${e.method}/${c(e.name)}` : "webhooks",
    getModelId: n,
    getHeadingId: a,
    getOperationId: (e, g) => {
      var d;
      return typeof t.value.generateOperationSlug == "function" ? `${o(g)}/${t.value.generateOperationSlug({
        path: e.path,
        operationId: e.operationId,
        method: e.httpVerb,
        summary: (d = e.information) == null ? void 0 : d.summary
      })}` : `${o(g)}/${e.httpVerb}${e.path}`;
    },
    getPathRoutingId: h,
    getSectionId: w,
    getTagId: o,
    isIntersectionEnabled: m,
    pathRouting: r,
    updateHash: I
  };
};
export {
  x as useNavState
};
